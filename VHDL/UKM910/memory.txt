c008 ; int0:   jump  main
c075 ; int1:   jump  int1sr
c07d ; int2:   jump  int2sr
c085 ; int3:   jump  int3sr
c08d ; int4:   jump  int4sr
c095 ; int5:   jump  int5sr
c09d ; int6:   jump  int6sr
c0a5 ; int7:   jump  int7sr
80be ; main:   load  spinit   # initial value for stack pointer
b000 ;         store $sp      # store value in stack pointer register
80ae ;         load  const1   # load constant 1 to ACC -> ACC = 1
10b6 ;         add   const9   # add 9         -> ACC = 10
20b2 ;         sub   const5   # substract 5   -> ACC = 5
30b3 ;         and   const6   # do AND with 6 -> ACC = 4
4000 ;         not            # invert        -> ACC = -5
5000 ;         comp           # complement    -> ACC = 5
6000 ;         rotr           # rotate right  -> ACC = -32766
e015 ;         bn    mark0    # branch to mark0
912a ; mark3:  store ADDR     # store result (1) at address 0x12A
20ae ;         sub   const1   # substract 1 -> ACC = 0
d01b ; mark1:  bz    mark4    # at ACC = 0 (should be the case here...) go to mark4
7000 ; mark0:  shr            # shift right -> ACC = 16385
0000 ;         nop            # no operation
e0d3 ;         bn    forbid0  # branch to forbid0 (to nothing..) -> should not be taken
d0d4 ;         bz    forbid1  # branch to forbid1 (to nothing..) -> should not be taken
30b4 ;         and   const7   # do AND  with 7 -> ACC = 1
c012 ;         jump  mark3    # jump to mark3
f02e ; mark4:  call  chkptrpsw # call subroutine which checks pointer and psw functionalities
80d0 ;         load  ieenmask  # enable interrupts 1-7
b005 ;         store $ien
80d1 ;         load  iflmask   # set interrupts 1-7 active
b006 ;         store $iflag
0000 ;         nop             # insert nops for case that interrupt service is delayed by 1 instruction
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
0000 ;         nop
80d2 ;         load  icnt      # check value of icnt -> were 7 interrupt service routines called?
20b4 ;         sub   const7
d02c ; marke:  bz    marke     # if yes, end with infinite loop
c0d3 ; jump    forbid0         # otherwise jump out
80c2 ; chkptrpsw: load  val1ad     # get address of first value
b001 ;         store $ptr1      # save in pointer 1
80c6 ;         load  val2ad     # get address of second value
b002 ;         store $ptr2      # save in pointer 2
80c9 ;         load  val3ad     # get address of third value
b003 ;         store $ptr3      # save in pointer 3
a011 ;         load  ($ptr1)    # load value: 0x5000 @ val1ad
10ae ;         add   const1     # add 1
b011 ;         store ($ptr1)    # store new value: 0x5001
a004 ;         load  $psw       # load status word
d03a ;         bz    cont1      # should be zero
c0d3 ;         jump  forbid0    # -> jump out if not
a021 ; cont1:  load ($ptr1)inc    # load value with post-increment: 0x5001 @ val1ad
90ca ;         store tmp1       # store in temporary variable
a032 ;         load  dec($ptr2)   # load value with pre-decrement: 0x7000 @ val2ad-1
10ca ;         add   tmp1       # add values -> carry bit should be not set, overflow bit should be set
a004 ;         load  $psw       # load psw
b023 ;         store ($ptr3)inc   # save this psw at val3ad
30cd ;         and   maskC      # check whether carry bit is set
d043 ;         bz    cont2      # if not, got to error area
c0d3 ;         jump  forbid0
b013 ; cont2:  store ($ptr3)    # store masked psw at val3ad+1
a033 ;         load  dec($ptr3)   # load psw
30ce ;         and   maskOV     # check if overflow bit is set
d0d3 ;         bz    forbid0
a012 ;         load  ($ptr2)    # load value: 0x7000 @ val2ad-1
90ca ;         store tmp1
a021 ;         load  ($ptr1)inc   # load value with post-increment: 0x1000 val1ad+1
20ca ;         sub   tmp1       # subtract -> negative result, carry bit should be not set, overflow should be not set
a004 ;         load  $psw       # load psw and...
b032 ;         store dec($ptr2)   # store @ val2ad-2
30cd ;         and   maskC      # check if carry bit is set
d050 ;         bz    cont3
c0d3 ;         jump  forbid0
a012 ; cont3:  load  ($ptr2)    # re-load psw and check if negative bit is set
30cc ;         and   maskN      # check if negative bit is set
d0d3 ;         bz    forbid0
a012 ;         load  ($ptr2)    # re-load psw and check if overlow bit is not set
30ce ;         and   maskOV
d057 ;         bz    cont4
c0d3 ;         jump  forbid0
a011 ; cont4:  load  ($ptr1)    # load value 0xA000 @ val1ad+2
20ae ;         sub   const1     # substract 1 -> carry should be set, overflow shouldn't
a004 ;         load  $psw       # load and store current psw
b012 ;         store ($ptr2)
30cd ;         and   maskC      # check if carry bit is set
d0d3 ;         bz    forbid0
a012 ;         load  ($ptr2)    # re-load psw
30ce ;         and   maskOV     # check if overflow bit is not set
d061 ;         bz    cont5
c0d3 ;         jump   forbid0
a032 ; cont5:  load  dec($ptr2)   # load value 0x4000 @ val2ad-3
90ca ;         store tmp1
a011 ;         load  ($ptr1)    # load value 0xA000 @ val1ad+2
20ca ;         sub   tmp1       # substract -> carry should be set, overflow should be set
a004 ;         load  $psw
90ca ;         store tmp1
30ce ;         and   maskOV     # check if overflow is set
d0d3 ;         bz    forbid0
80ca ;         load  tmp1
30cd ;         and   maskC      # check if carry is set
d0d3 ;         bz    forbid0
80ad ;         load  const0     # load 0 -> zero-flag should be set
a004 ;         load  $psw
30cb ;         and   maskZ      # check if it is set
d0d3 ;         bz    forbid0
a004 ;         load  $psw       # now Z and N in psw should be reset
30cf ;         and   maskZN
d074 ;         bz    cont6      # check if zero
c0d3 ;         jump  forbid0
a100 ; cont6:  ret              # return
a004 ; int1sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop            # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int2sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int3sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int4sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int5sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int6sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
a004 ; int7sr: load  $psw    # load psw and push on stack
b030 ;         push
80d2 ;         load  icnt    # add 1 to icnt variable
10ae ;         add   const1
90d2 ;         store icnt
a020 ;         pop           # pop psw from stack
b004 ;         store $psw
a200 ;         reti          # return from interrupt
0000 ; const0: .word 0x000
0001 ; const1: .word 0x001
0002 ; const2: .word 0x002
0003 ; const3: .word 0x003
0004 ; const4: .word 0x004
0005 ; const5: .word 0x005
0006 ; const6: .word 0x006
0007 ; const7: .word 0x007
0008 ; const8: .word 0x008
0009 ; const9: .word 0x009
000a ; constA: .word 0x00A
000b ; constB: .word 0x00B
000c ; constC: .word 0x00C
000d ; constD: .word 0x00D
000e ; constE: .word 0x00E
000f ; constF: .word 0x00F
00ad ; const0Addr: getaddr const0
07ff ; spinit: .word 0x7FF
5000 ; vals1:  .word 0x5000
1000 ;         .word 0x1000
a000 ;         .word 0xA000
00bf ; val1ad: getaddr vals1
4000 ; vals2:  .word 0x4000
0000 ;         .word 0x0000
7000 ;         .word 0x7000
00c6 ; val2ad: getaddr val2ad
0000 ; vals3:  .fill 2,2
0000 ; val3ad: getaddr val3ad
00c9 ; val3ad: getaddr val3ad
0000 ; tmp1:   .word 0x0000
0001 ; maskZ:  .word 0x0001
0002 ; maskN:  .word 0x0002
0004 ; maskC:  .word 0x0004
0008 ; maskOV: .word 0x0008
0003 ; maskZN: .word 0x0003
01fe ; ieenmask: .word 0x01FE
00fe ; iflmask:  .word 0x00FE
0000 ; icnt:     .word 0x0000
0000 ; forbid0: nop
0000 ; forbid1: nop
